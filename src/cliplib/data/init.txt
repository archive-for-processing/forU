
// smile 
 // :{ .{ ; :} .} ; :x .x ; :[ .[ ; :] .] ;
// common errors
 :}} .}} ; //  :e .e ; :b .b ; :v .v ;
// repeaters..may get superflous too
 :4 $ $ $ $ ; :2 $ $ ;  :1 $ ; :3 $ $ $ ; :0 ;
   :5 $ $ $ $ $ ; :6 ( $ $ $  ) 2 ;  :7 ( $ )  6 $ ; 
   :9 ( $ $ $ ) 3 ;
  :10 ( $  $ ) 5 ; // etc
     :8 ( $ $ ) 4 ; 
   :16 ( $ $ ) 8 ; 
    :64 ( ( $ ) 8 ) 8 ;
    :32 ( ( $ ) 8 ) 4 ;
   :12 ( $ $ ) 6 ;
   :17 $ ( $ ) 16 ;
  
   :center ./2xy  ;
    :rim  .*2x-2y-2 ; 

   :C { center $ } ;
   :N ( $ ) $1 ;
  :N+1 ( $ ) $1 ( $ ) 1  ;

     :_poly_step { .xv } .<$  ; 
    :_poly  center  .b ( $ , ( $ ) _poly_step ) N+1  ;
  // 2 more for smoothing..but curve should detect that?
    :_cpoly { ( $ ) _poly ( ( $  ) _poly_step ) 2 .c } ;
     :ppoly { ( $ ) _poly } ;
     :pcircle { ( 8 ) ppoly  .c20 } ; 
     
     :circle pcircle .e ;
     :poly ppoly .e ;
     
     :_vx  ( ( $ ) vx$ ) $ ; 
     :prectN .b { (  ( $ ) _vx .> ) 4  .} .v ;  // only the path
     :prect ( 4 ) prectN ;
     :rect  prect .e ; 

      :central center $ rim ;
      :smaller (   ./$  ) central ;
      :smaller10 ./12xy*10 ;
     :smaller7 ./9xy*7 ; 
     :smaller8 ./10xy*8 ; 
     :smaller2 ./4xy*2 ;
       :smaller4 ./6xy*4 ;
     :smaller1 ./3xy ; 
      :smaller0 smaller1 ;

     :srect .{ smaller6 rect } ;
     :smaller6  ./8xy*6 ;

      :quad ( $ , $ ) checker ;
    

     :row8 { ( $ .y ) 8 } ; 
     :col8 { ( $ .x ) 8 } ;
     :brd8 ( ( $ ) row8 ) col8 ; 
     :board8 .{/8 ( $ ) brd8 } ;
    :board8x ( $ , $ ) chess ;
     :checker { ./2 $ { .y $1 } .x $1 .y $ } ;  
      :chess4 ( ( $ , $1 ) checker ) quad  ;
      :chess ( ( $   , $1 ) chess4 ) quad ;
     
       :smallboard { smaller7 ( $ ) board8 } ; 
      :sboard ( srect ) board8 ;
  

     :in{ { .!2 .{ .!1{ smaller2  ( 5 )  ppoly  ; 
    :out} }}} ;
     // a distorter with empty param sets just a path
    // which can be used for drawing inside with distortiom
    // but better limit the area before and push tje clip
   // area for lazer restoring
    // after finishing drawing into it, we restore clip
   // and now reserve this area
  
  :subccpic // (  innermotiv , pathmaker  )
     [ ( ) $ limit (  $1 )  $  ]  (  ) $ reserve ;
    :reserve .r ;   
    :inside  [ (  ) $ .l  ( $1 ) $   ] ;
   :limit .l ;
  :string { $1 [ $ ] } ;
  :strin%%g  ( $ , $1 ) subpic ;

 // so if we want to draw inside something like
   :motiv ( { smaller7 rect } ,  rect ) chess4 ;

   :flag  in{  i8e [  motiv  ]
     // e h64 motiv  
   out} ;

   :dart { ./3 .b .yvxxv<xv>xyy2v .>xx2yv>yvxxv>xv } .e  ;
    :ptri { ./2b{vxxyv}{yyv}v } ; 
   :tri ptri e ;
   :aura ./8ie*8 ; 
  :frames { /8xy$#frames dart reserve } ;
  
  :hatch  { ( .{bvyvx8/6e} ( $ ) .x$ ) $ } ; 
  :hand { .*$ .bvxv} .L15m60e ;  
   :60 ( $ $ $ $ $ $ ) 10 ; 
   :tick { .x/13bvx-1ve } ;  
   
  :hatched { $ [  ( $1 ) hatch ] } ;
   :h64 {  ( 64 ) hatch } ;

  :qmark { .x>>/2Y0.5y-2  tri  reserve } ;  
  :hmark { .x>>/6Y0.5y-2 rect reserve } ; 

  :clock // ( face ) limit and rotate for screen  
     {   circle [ center  
  // draw hands
   { .>$#second   .Y0.2y-2 dart reserve }  
   { .>$#minute ( 0.9 ) hand reserve }  
   { .>$#hourhand ( 0.7 ) hand reserve }  
//   { .>$#millis  .x1.2/8  tri   reserve }  
  // hour markers
  { ( qmark .>4 ) 4 } 
  { ( hmark .>12 ) 12 }  
  //  { ( tick .>60 ) 60 } 
  }
   {  $  } // the face 
     ]  ; 
 
   :smallclock { smaller6
        /3y$#second  (
       //  center .>18 rim ( circle  , srect ) chess4
         ) clock } ;   
 

    