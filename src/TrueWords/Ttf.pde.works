/**
 * Words.
 * 
 * The text() function is used for writing words to the screen.
 */



import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.ByteOrder;


import java.util.Map;

interface Cmap {
   // int format;
    int get(int i);
  }
  

class Ttf {
  String name;
  ByteBuffer file;
  int scalarType;
  short numTables;
  int searchRange, entrySelector, 
    rangeShift;
  int length;
  HashMap<String, Table> tables;
 
  
  Ttf(String name) { 

    this.name=name;
    
    set(mapFile(name));
  }

  Ttf(ByteBuffer file){
    set(file);
  }
  
  void set(ByteBuffer file) {
    this.file=file;
    file.order(ByteOrder.BIG_ENDIAN) ;
    loadTables();
    this.length = this.getGlyphCount();
    loadCmap();
    readHheaTable();
    logprintln("loadhead bot "+version+" length: "+this.length);
    logprintln("unitsPerEm: "+unitsPerEm);
  }

  int getGlyphCount() {
    //assert("maxp" in this.tables);

           /// this.file.position(
      int ofs=this.tables.get("maxp").offset + 4;
    logprintln("maxp offset "+ofs);
    file.position(ofs);
            int count = this.filegetUint16();

            return count;
  }


  String getString(int n) {
    byte buf[] =new byte[n];
    file.get(buf );//,0,n);
    return new String(buf);
  }

  class Table {
    int cs, offset, length;
    String tag;
    Table(String tag) {
      this.tag=tag;
      cs= file.getInt();    
       offset=file.getInt();    
       length=file.getInt();
      logprintln("table "+tag+" "+length);
    }
  }
  int filegetUint32() { 
    return file.getInt();
  };

  int filegetUint16() { 
    return file.getShort();
  };

  int filegetUint8() { 
    // watch out for signed here
    return file.get() & 0xff;
  };

  int filegetInt16() { 
    return file.getShort();
  };

  int filegetFword() { 
    return file.getShort();
  };

  int filegetDate() { 
    file.getInt();
    return file.getInt();
  };
  float filegetFixed() {
    return (file.getInt() *1.0)/ (1 << 16);
  };

  int fileseek(int po) {
    int t=file.position();
    file.position(po);
    return t;
  }

  float version, fontRevision;
  int checksumAdjustment, magicNumber, 
    flags, unitsPerEm, created, modified;
  int xMin, yMin, xMax, yMax, macStyle;
  int lowestRecPPEM, fontDirectionHint;
  int indexToLocFormat, 
    glyphDataFormat;

  //class Head {
  void loadHead() { 
    fileseek(tables.get("head").offset); 
    this.version = filegetFixed(); 
    this.fontRevision = filegetFixed(); 
    this.checksumAdjustment = filegetUint32(); 
    this.magicNumber = filegetUint32();
   // assert(this.magicNumber == 0x5f0f3cf5);
    this.flags = filegetUint16(); 
    this.unitsPerEm = filegetUint16();
    this.created = filegetDate(); 
    this.modified = filegetDate(); 
    this.xMin = filegetFword(); 
    this.yMin = filegetFword();
    this.xMax = filegetFword(); 
    this.yMax = filegetFword();
    this.macStyle = filegetUint16();
    this.lowestRecPPEM = filegetUint16(); 
    this.fontDirectionHint = filegetInt16();
    this.indexToLocFormat = filegetInt16();
    this.glyphDataFormat = filegetInt16();
  }
  // }

  void loadTables() {
    logprintln("loading "+name);
      this.scalarType = file.getInt();
     int numTables = file.getShort();
    logprintln("tables: "+numTables);
     this.searchRange = file.getShort();
     this.entrySelector = file.getShort();
    this.rangeShift = file.getShort();
    tables=new HashMap<String, Table>();
    for (int i = 0; i < numTables; i++) { 
             
         String tag = getString(4);
      Table t= new Table(tag);
        tables.put(tag, t);
    }
    loadHead();
  };

  int getGlyphOffset(int index) {
    logprintln("szstt glyphoffset "+ index);
           // assert("loca" in this.tables);

            Table table = this.tables.get("loca");

           // println("table "+table.tag+" offset="+table.offset);
              int offset, next;
            if (this.indexToLocFormat == 1) {
            fileseek(table.offset + index * 4);
                  offset = filegetUint32();
                  next = filegetUint32();
              
    } else {
                  fileseek(table.offset + index * 2);
                  offset = filegetUint16() * 2;
                  next = filegetUint16() * 2;
              
    }
            if (offset == next) {
              // indicates glyph has no outline( eg space)
              return 0;  
              
    }
         logprintln("Offset for glyph index "+index+" is "+offset);

            return offset + this.tables.get("glyf").offset;   
        
  }
  
  int ascent,descent,lineGap,advanceWidthMax;
  int minLeftSideBearing,minRightSideBearing;
  int xMaxExtent,caretSlopeRise,caretSlopeRun;
  int caretOffset,metricDataFormat,numOfLongHorMetrics;
  
  void readHheaTable() {
       // assert("hhea" in this.tables);
        int tableOffset = this.tables.get("hhea").offset;
        fileseek(tableOffset);
        // int version = 
        filegetFixed(); // 0x00010000
        this.ascent = filegetFword();
        this.descent = filegetFword();
        this.lineGap = filegetFword();
        this.advanceWidthMax = filegetFword();//UF
        this.minLeftSideBearing = filegetFword();
        this.minRightSideBearing = filegetFword();
        this.xMaxExtent = filegetFword();
        this.caretSlopeRise = filegetInt16();
        this.caretSlopeRun = filegetInt16();
        this.caretOffset = filegetFword();
        filegetInt16(); // reserved
        filegetInt16(); // reserved
        filegetInt16(); // reserved
        filegetInt16(); // reserved
        this.metricDataFormat = filegetInt16();
        this.numOfLongHorMetrics = filegetUint16();
    }

    PVector getHorizontalMetrics(int glyphIndex) {
       // assert("hmtx" in this.tables);
        
        int old = fileseek(this.tables.get("hmtx").offset + 4);
        int offset = this.tables.get("hmtx").offset;
        int advanceWidth, leftSideBearing;
        if (glyphIndex < this.numOfLongHorMetrics) {
            offset += glyphIndex * 4;
            old = fileseek(offset);
            advanceWidth = filegetUint16();
            leftSideBearing = filegetInt16();
        } else {
            // read the last entry of the hMetrics array
            old = fileseek(offset + (this.numOfLongHorMetrics - 1) * 4);
            advanceWidth = filegetUint16();
            fileseek(offset + this.numOfLongHorMetrics * 4 +
                2 * (glyphIndex - this.numOfLongHorMetrics));
            leftSideBearing = filegetFword();
        }

        this.fileseek(old);
        return new PVector (advanceWidth,leftSideBearing);
        
       //    advanceWidth: advanceWidth,
       //     leftSideBearing: leftSideBearing
       
    }


  class Glyph {
    int xMin, xMax, yMax, yMin;
    int numberOfContours=0;
    int offset;
    int numPoints;
    PVector hMetrics;
    
    Glyph( int index) { 
      offset = getGlyphOffset(index); 
      numberOfContours=0;
      if (offset==0) return;
      if (offset >= tables.get("glyf").offset
        + tables.get("glyf").length) 
      { 
        logprintln(" glyph offset too lreturn null");
      }
      // assert(offset >= this.tables["glyf"].offset); 
      // assert(offset < this.tables["glyf"].offset + this.tables["glyf"].length); 
      fileseek(offset); 
      // var glyph = { 
      numberOfContours=filegetInt16();
      xMin= filegetFword();
      yMin= filegetFword();
      xMax= filegetFword();
      yMax= filegetFword(); 
      //assert(glyph.numberOfContours >= -1);
      if (numberOfContours == -1) { 
        logprintln("compound!!!!!");
        //   readCompoundGlyph( this);
      } else { 
        readSimpleGlyph();
      }
      hMetrics=getHorizontalMetrics(index);
      if(hMetrics==null)
        hMetrics=new PVector(yMax,0);
    };

    boolean isSimple=true;
    int contourEnds[];
    PVector points[];
    int flags[];

    final int 
      ON_CURVE = 1, 
      X_IS_BYTE = 2, 
      Y_IS_BYTE = 4, 
      REPEAT = 8, 
      X_DELTA = 16, 
      Y_DELTA = 32; 


    void readSimpleGlyph() {

      logprintln("simple contours : "+numberOfContours);
      contourEnds = new int[numberOfContours];
      int cmax=0;
      for ( int i = 0; i < numberOfContours; i++ ) 
      { 
        contourEnds[i]=filegetUint16();
        if (contourEnds[i]>cmax)
          cmax= contourEnds[i];
      };
      // skip over intructions 
      fileseek(filegetUint16() + file.position());
      if (numberOfContours == 0) { 
        return;
      } 
      numPoints = cmax + 1; 
      logprintln("points "+numPoints);
      flags = new int[numPoints]; 
      points=new PVector[numPoints];

      for ( int pi = 0; pi < numPoints; pi++ ) { 
        int flag = filegetUint8(); 
        flags[pi]=flag; 
        points[pi]=new PVector(0, 0);
        if ( (flag & REPEAT) !=0 ) { 
          int repeatCount = filegetUint8(); 
          // assert(repeatCount > 0); 
          logprintln("repeat "+repeatCount+" from "+pi);
          while (repeatCount-->0) {          
            pi++;
            flags[pi]=flag;
            points[pi]=new PVector(0, 0);
          }
        }
      } // numpoints
      readCoords(true, X_IS_BYTE, X_DELTA, 
        xMin, xMax);
      readCoords(false, Y_IS_BYTE, Y_DELTA, 
        yMin, yMax);
      //  println("points "+points.length);
    }

    void readCoords(
      boolean forX, 
      int byteFlag, 
      int deltaFlag, 
      int min, 
      int max) {

      int value = 0; 
      for ( int i = 0; i < numPoints; i++ ) {
        int flag = flags[i]; 
        //    println("flag ",flag);
        if ( (flag & byteFlag ) !=0) { 
          if ( (flag & deltaFlag )!=0) { 
            value += filegetUint8();
          } else {
            value -= filegetUint8();
          }
        } else if ( !((flag & deltaFlag) !=0)) {
          value += filegetInt16();
        } else { 
          // value is unchanged.
        }
        if (forX) 
          points[i].x = value;
        else
          points[i].y = -value;
      }
      // println("coords "+numPoints);
    }

    boolean onCurve(int i)
    {
      return (flags[i]&ON_CURVE)!=0;
      // return false;
    }

    void draw() {
      draw(0, 0);
    }
    
    class defSc implements ShapeCreator {    
      void beginShape(){ me.beginShape() ;};
      void vertex(float x,float y){
        me.vertex(x,y);
      };
      void endShape(int mode){me.endShape(mode);};
      void quadraticVertex(float cx, float cy,
        float x,float y){me.quadraticVertex(cx,cy,x,y);};
      void curveVertex(
        float x,float y){me.curveVertex(x,y);};
      void beginContour(){me.beginContour();};
      void endContour(){me.endContour();};
    }
    
    void draw(float x, float y) { 
       draw(new defSc(),x,y);
    }
    
    void draw(ShapeCreator cr,float x, float y) { 

      if (numberOfContours<=0||!isSimple)return;
      int p = 0, c = 0, 
        s = 0, contourStart=0;
      PVector prev;
      cr.beginShape();
      while (p < points.length) { 
        PVector point = points[p]; 

        if (s == 0) {
          if(p!=0)
            beginContour ();
          
          cr.vertex(point.x+x, point.y+y);
          // ctx.moveTo(point.x + x, point.y + y);
          s = 1;
        } else if (s == 1) {
          if (onCurve(p)) {
            cr.vertex(point.x+x, point.y +y);
            // set first cp??
          } else {
            s = 2; // or set prev...
          }
        } else {
          prev = points[p - 1];
          if (onCurve(p)) {
            cr.quadraticVertex(prev.x + x, prev.y + y, 
              point.x + x, point.y + y);
            s = 1;
          } else { // really???
            cr.quadraticVertex(prev.x + x, prev.y + y, 
              (prev.x + point.x) / 2 + x, 
              (prev.y + point.y) / 2 + y);
          }
        }
        if (p == contourEnds[c]) {
          if (s == 2) { // final point was off-curve. connect to start
            prev = point;
            point = points[contourStart];
            if (onCurve(contourStart)) {
              cr.quadraticVertex(prev.x + x, prev.y + y, 
                point.x + x, point.y + y);
            } else {
              cr.quadraticVertex(prev.x + x, prev.y + y, 
                (prev.x + point.x) / 2 + x, 
                (prev.y + point.y) / 2 + y);
            }
          }
          if(p>0) endContour();
          contourStart = p + 1;
          c += 1;
          s = 0;
        }
        p += 1;
      }
      cr. endShape(CLOSE);
    } // draw
  } // glyph

  Glyph getGlyph(int i) {
    return new Glyph(i);
  }
  
HashMap<Integer,Cmap> cmaps;

@SuppressWarnings("unused")
  void loadCmap() {
    //  assert("cmap" in this.tables);
    cmaps=new HashMap<Integer,Cmap>();
    int tableOffset = this.tables.get("cmap").offset;
    fileseek(tableOffset);
    int version = filegetUint16(); // must be 0
    int numberSubtables = filegetUint16();

    // tables must be sorted by platform id and then platform specific
    // encoding.
    for (int i = 0; i < numberSubtables; i++) {
      // platforms are: 
      // 0 - Unicode -- use specific id 6 for full coverage. 0/4 common.
      // 1 - MAcintosh (Discouraged)
      // 2 - reserved
      // 3 - Microsoft
      int platformID = filegetUint16();
      int platformSpecificID = filegetUint16();
      int offset = filegetUint32();
   logprintln("CMap platformid="+platformID 
   +" specificid="+platformSpecificID);
    if (platformID == 0)
     {
       if(readCmap(tableOffset+offset))
         break;
     }
     if (platformID == 3 && (platformSpecificID <= 1)) {
       if( readCmap(tableOffset + offset)){
         break;
       }
      }
    }

    // use unicode table preferably.
    //
  }

  

  class Cmap0 extends HashMap<Integer,Integer> implements Cmap {
    Cmap0() {
     // format=0;
      for (int i = 0; i < 256; i++) {
        int glyphIndex = filegetUint8();
        //  this.log("   Glyph[%s] = %s", i, glyphIndex);         
        put(i, glyphIndex);
      }
    }
    int get(int i){
      return super.get(i);
    }
  }
   
  
  
@SuppressWarnings("unused")
  boolean readCmap(int offset) {
    int oldPos = fileseek(offset);
    int format = filegetUint16();
    int length = filegetUint16();
    int language = filegetUint16();
    Cmap cmap=null;

  logprintln("    Cmap format "+format+" length "+ length);
    if (format == 0) {
      cmap = new Cmap0();
    } else if (format == 4) {
      cmap= new Cmap4();
    }
    fileseek(oldPos);
    if (cmap!=null) {
      this.cmaps.put(format,cmap);
      return true;
    }

    return false;
  }
  
  
/**
    Cmap format 4 is a list of segments which can possibly include gaps
*/
class Cmap4  implements Cmap {
   // format = 4;
    class Segment {
      int endCode=0;
      int startCode=0;
      int idDelta=0;
      int idRangeOffset=0;
    }
    
    Segment segments[];
    //: Segment[];


@SuppressWarnings("unused")
    Cmap4() {
        int i;

        // 2x segcount
        int segCount = filegetUint16() / 2;
        segments = new Segment[segCount];
        // 2 * (2**floor(log2(segCount)))
        int searchRange = filegetUint16();
        // log2(searchRange)
        int entrySelector = filegetUint16();
        // (2*segCount) - searchRange
        int rangeShift = filegetUint16();
        // Ending character code for each segment, last is 0xffff
        for (i = 0; i < segCount; i++) {
            segments[i]=new Segment();
            segments[i].endCode=
            
                filegetUint16();
        }

        // reservePAd
        filegetUint16();

        // starting character code for each segment
        for (i = 0; i < segCount; i++) {
            segments[i].startCode = filegetUint16();
        }

        // Delta for all character codes in segment
        for (i = 0; i < segCount; i++) {
            segments[i].idDelta = filegetUint16();
        }

        // offset in bytes to glyph indexArray, or 0
        for (i = 0; i < segCount; i++) {
            int ro = filegetUint16();
            if (ro>0) {
                segments[i].idRangeOffset = file.position() - 2 + ro;
            } else {
                segments[i].idRangeOffset = 0;
            }
        }

        /*
        for(i = 0; i < segCount; i++) {
            var seg = segments[i];
            this.log("segment[%s] = %s %s %s %s", i,
                seg.startCode, seg.endCode, seg.idDelta, seg.idRangeOffset);
        }
        */
      } // create

    

     int get(int charCode) {
    
            for (int j = 0; j < segments.length; j++) {
                Segment segment = this.segments[j];
                if (segment.startCode <= charCode && segment.endCode >=
                    charCode) {
                    int index, glyphIndexAddress;
                    if (segment.idRangeOffset!=0) {
                        glyphIndexAddress = segment.idRangeOffset + 2 *
                            (charCode - segment.startCode);
                       fileseek(glyphIndexAddress);
                        index = filegetUint16();
                    } else {
                        index = (segment.idDelta + charCode) & 0xffff;
                    }

                    //this.log("Charcode %s is between %s and %s; maps to %s (%s) roffset=%s",
                    //    charCode, segment.startCode, segment.endCode,
                    //    glyphIndexAddress, index, segment.idRangeOffset);  
                   return index;
                }
            }     

        return 0;
    }
   } // Cmap4
  
  int cmapped(int i){
    int format=4;
    if(cmaps.containsKey(format)){
      return cmaps.get(format).get(i);
    }
    format=0;
    if(i<255&&cmaps.containsKey(format)){
      return cmaps.get(format).get(i);
    }
    // now what???
    
    return 0;
  }
  
  HashMap <Integer,Glyph>glcache=new HashMap<Integer,Glyph>();
 
  Glyph cg(int ch){
    if(glcache.containsKey(ch)){
      return glcache.get(ch);
    }
    Glyph gl=getGlyph(cmapped(ch));
    glcache.put(ch,gl);
    return gl;
  }
  
  void transform(float size) {
      scale(size / this.unitsPerEm);
  }

  float textsize= 64;
  void textSize(float t){
    textsize=t;
  }
  void drawRaw(char ch,float x,float y){
    cg(ch).draw(x,y);
  }
  void draw(char ch,int size){
    pushMatrix();
    transform(size);
    drawRaw(ch,0,0);
    popMatrix();
  }
  void draw(String t){
    pushMatrix();
    transform(textsize);
    float x=0;
    float y=0;
    for(char ch:t.toCharArray()){
       drawRaw(ch,x,y);
       PVector m=cg(ch).hMetrics;
       if(m==null)
         logprintln("oops, no metric on "+cg(ch));
       else
         x+=m.x;
    }
    popMatrix();
  }
  
} // Ttf


public static ByteBuffer mapFile(String name) {

  RandomAccessFile memoryFile;

  try {
    memoryFile = new RandomAccessFile(name, "rw");
    long fsize=memoryFile.length();
    return
      memoryFile
      .getChannel()
      .map(FileChannel.MapMode.
      READ_ONLY, 
      //  READ_WRITE, 
      0, fsize);
  } 
  catch (Exception e) {
    PApplet.println("mem: no file "+name);
    //e.printStackTrace();
    //throw e;
  }
  return null;
}
