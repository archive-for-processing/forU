
// smile 
 // :{ .{ ; :} .} ; :x .x ; :[ .[ ; :] .] ;
// common errors
 :}} .}} ; //  :e .e ; :b .b ; :v .v ;
// repeaters..may get superflous too
 :4 $ $ $ $ ; :2 $ $ ;  :1 $ ; :3 $ $ $ ; :0 ;
   :5 $ $ $ $ $ ; :6 ( $ $ $  ) 2 ;  :7 ( $ )  6 $ ; 
   :9 ( $ $ $ ) 3 ;
  :10 ( $  $ ) 5 ; // etc
     :8 ( $ $ ) 4 ; 
   :16 ( $ $ ) 8 ; 
    :64 ( ( $ ) 8 ) 8 ;
    :32 ( ( $ ) 8 ) 4 ;
   :12 ( $ $ ) 6 ;
   :17 $ ( $ ) 16 ;
  
   :center ./2xy  ;
    :rim  .*2x-2y-2 ; 

   :Cxxx { center $ } ;
   :N ( $ ) $1 ;
  :N+1 ( $ ) $1 ( $ ) 1  ;

     :_poly_step { .xv } .<$  ; 
    :_poly  center  ( $ , ( $ ) _poly_step ) N+1  ;
  // 2 more for smoothing..but curve should detect that?
    :_cpoly { ( $ ) _poly ( ( $  ) _poly_step ) 2 .c } ;
     :ppoly { ( $ ) _poly } ;
     :pcircle { ( 8 ) ppoly  .c20 } ; 
     
     :circle b pcircle .e ;
     :poly b ppoly .e ;
     
     :_vx  ( ( $ ) .vx$ ) $ ; 
     :_vx4 ( .vx4 ) 4 ;
     :prect4  { ( _vx4  > ) 4 } v ;
     :prectN  { (  ( $ ) _vx .> ) 4  .} .v ;  // only the path
     :prect prect4 ; // ( 4 ) prectN ;
   
     :rect  b prect .e ; 

      :central center $ rim ;
      :smaller (   ./$  ) central ;
      :smaller10 ./12xy*10 ;
     :smaller7 ./9xy*7 ; 
     :smaller8 ./10xy*8 ; 
     :smaller2 ./4xy*2 ;
       :smaller4 ./6xy*4 ;
     :smaller1 ./3xy ; 
      :smaller0 smaller1 ;

     :srect .{ smaller6 rect } ;
     :smaller6  ./8xy*6 ;

      :quad ( $ , $ ) checker ;
    

     :row8 { ( $ .y ) 8 } ; 
     :col8 { ( $ .x ) 8 } ;
     :brd8 ( ( $ ) row8 ) col8 ; 
     :board8 .{/8 ( $ ) brd8 } ;
    :board8x ( $ , $ ) chess ;
     :checker { ./2 $ { .y $1 } .x $1 .y $ } ;  
      :chess4 ( ( $ , $1 ) checker ) quad  ;
      :chess ( ( $   , $1 ) chess4 ) quad ;
     
       :smallboard { smaller7 ( $ ) board8 } ; 
      :sboard ( srect ) board8 ;
  

     // a distorter with empty param sets just a path
    // which can be used for drawing inside with distortiom
    // but better limit the area before and push tje clip
   // area for later restoring
    // after finishing drawing into it, we restore clip
   // and now reserve this area
  
    :reserve .r ;   
    :inside  [ (  ) $ .l  ( $1 ) $   ] ;
   :limit .l ;
  :string { $1 [ $ ] } ;
  
  :q0 { /2 b prect [ center *0.95 rim rect limit $ ] } ;
  :q1 { y2 ( $ ) q0 } ; :q2 { x2 q0 } ; :q3 { x2y2 q0 } ;
  :warp{ .{!1 ;
  :_tback >>  $ >> ; 
  :warpT { $ warp{ { ( $ )  _tback $1 } } } ;
  :warpS { *$ warp{ { /$ $1 } } } ;
  // ( n , what )
   :warpN ( $1 , ( $ ) ./$y3*$  ) warpT ;

 // so if we want to draw inside something like
  
     :in{ { .!2 .{ .!1{ smaller2 b ( 5 )  ppoly  ; 
    :out} }}} ;
   :motiv ( { smaller7 rect } ,  rect ) chess4 ;
   :flag  in{  i8e // ad a small rim and show it
      [  motiv  ]
     // e h64 motiv  
   out} ;

   :pdart { ./3 .yvxxv<xv>xyy2v .>xx2yv>yvxxv>xv }   ;
  :dart b pdart .e ;
   :ptri { ./2{vxxyv}{yyv}v } ; 
   :tri b ptri e ;
   :aura .i8e ; 
  :frames { /8xy$#frames dart reserve } ;
  
  :hatch  { ( .{bvyvx8/6e} ( $ ) .x$ ) $ } ; 
  :hand { .*$ .bvxv} .L15m60e ;  
   :60 ( $ $ $ $ $ $ ) 10 ; 
   :tick { .x/13bvx-1ve } ;  
   
  :hatched { $ [  ( $1 ) hatch ] } ;
   :h64 {  ( 64 ) hatch } ;

  :qmark { .x>>/2Y0.5y-2  tri  reserve } ;  
  :hmark { .x>>/6Y0.5y-2 rect reserve } ; 

  :clock // ( face ) limit and rotate for screen  
     {   circle [ center  
  // draw hands
   { .>$#second   .Y0.2y-2 dart reserve }  
   { .>$#minute ( 0.9 ) hand reserve }  
   { .>$#hourhand ( 0.7 ) hand reserve }  
//   { .>$#millis  .x1.2/8  tri   reserve }  
  // hour markers
  { ( qmark .>4 ) 4 } 
  { ( hmark .>12 ) 12 }  
  //  { ( tick .>60 ) 60 } 
  }
   {  $  } // the face 
     ]  ; 
 
   :smallclock { smaller6
        /3y$#second  (
       //  center .>18 rim ( circle  , srect ) chess4
         ) clock } ;   
 
    :back  ( srect ,  circle ) chess ;
    :Date {/3xxy5/7b  #Font#font  #Date  .ei3e reserve } ;

  :emingle // like a rect, spiral in
      {  .b  ( vxvy*0.9>> ) 8 } ;

    :rotated { .x2y2 $1 .>>x2y2>> $ } ;
   :back2 ( ( {!1 smaller8 emingle ce }  , srect reserve ) chess ) 1 ; 

  
   :_grow { $ ( m40 ) $1 er }  ;
   :bla0 ( 0 , $1 , $ ) bla  ; 
   :bla1 ( $1 , $ ) bla0 ( 1 , $1 , $ ) bla ; 
  :bla2 ( $1 , $ ) bla1 ( 2 , $1 , $ ) bla ; 
  :bla3 ( $1 , $ ) bla2 ( 3 , $1 , $ ) bla ; 
  :bla ( $2 , $1 ) _grow ( $2 , $ ) _grow ; 

 :grimi { /6 yy2x2v xy2vxv <x2y2v xy2v v // snout
   >yx2vx2v xyv >xyv v // horn 
   >yx-2v x2y2v xv <xy2v  
   xv xyv v // tail 
    >yx-2v v  // end tail
   <x2yv yx-2v >>yv // hindmost foot
  <xy2v  >yv y2v // end hind legs
   x2v <xy2v x2y2v // foot 
   >yx-4v <xyy-4v 
  } ; 

  :chess16 ( ( $ , $1 ) chess ) quad ;
 
    #Font#linear-b#linear-b.ttf#1.2
    #Font#arkhip#Arkhip_font.ttf#0.8
    #Font#font#font.ttf 
    #Font#cousine#Cousine-Regular.ttf 
    #Font#meslo#MesloLGS-Regular.ttf 
    #Font#awesome#FontAwesome.ttf
    #Font#script#AbrazoScriptSSiNormal.ttf
    // #Font#Jacobs#JakobsHandwriting.ttf
    #Font#slogan#slogan.ttf#0.9 // umlaut
    #Font#stencil#stencil.ttf#0.7
    #Font#litho#lithograph.ttf
    #Font#klingon#BEK.ttf
    #Font#uni#CODE2001.TTF#0.9 // compose
    
 
 

    